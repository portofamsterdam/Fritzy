# Fritzy2.0: A Showcase For Decentral Organisation Of Industrial Energy

## Uitgangspunten
• Learn by experiment.
• Real: the essence, as simple a possible.
• Interesting: easily understandable.
• Experimental: easily adjustable.
• Contagious: easy to connect.

Fritzy2.0 consists of four devices which locally trade energy to avoid congestion on the energy network while also getting a better deal for the energy price. The devices are a fridge (Fritzy), a PV installation (Sunny), a battery (Batty) and a net connection (Exxy). The devices trade energy among themselves to avoid buying energy from the net which is simulated by Exxy. All actors have to comply by the rules set by the net provider which is simulated by Netty. Netty can be configured to reduce the available amount of capacity on the network, forcing local trade. Netty can also stimulate local trade by giving rewards to local traders. 

# Prerequisites
Docker <TODO version>
Gradle 4.9

# Build
In this repo are five docker applications which can be built with the following commands.   
$ cd gradle/
$ ./gradlew.sh copyArtifactsToDocker
$ cd ../docker/build/fritzy
$ docker build -t fritzy2/fritzy:fritzy .
$ cd ../batty
$ docker build -t fritzy2/fritzy:batty .
$ cd ../netty
$ docker build -t fritzy2/fritzy:netty .
$ cd ../sunny
$ docker build -t fritzy2/fritzy:sunny .
$ cd ../exxy
$ docker build -t fritzy2/fritzy:exxy .

The images can be run individually by setting the correct config directory. The images are run as part of Fritzy with the Docker compose file in <TODO set fritzy git url>.

## Device

Each device is responsible for controlling its own hardware and trading. The device and trading mechanisms are separated by the Efi standard (see below) which makes devices and trading algorithms more portable.

## FritzyApi

Each device trades on the market using the fritzy api. It connect to a blockchain market for trading energy. Every actor is allowed to mint and burn energy on the market. Energy minted should be used (burned) or sold in a given trade period. For now trade periods are a set 15 minutes. In a trading period energy is bought and sold for the next 15 minute period. E.g. energy sold between 11:30 and 11:45 is used or generated by the device between 11:45 and 12:00. Euro tokens should be created for the devices which have to buy energy like the fridge.  

## Efi

Devices express their energy requirements using Efi messages. This way trading algorithms can be built on a standard set of Efi messages and reused for multiple devices following similar energy patterns. 

The standard is currently awaiting approval to become european standard:
https://joinup.ec.europa.eu/solution/dsfpren-50491-12-general-requirements-home-and-building-electronic-systems-hbes-and-building/distribution/dsfpren-50491-12-general-requirements-home-and-building-electronic-systems-hbes-and-building

# Configuraties

## Fritzy
/** EFI id of the device */
@JsonProperty("deviceId")

/** host address of webrelay */
@JsonProperty("host")

/** Port of webrelay (default 80) */
@JsonProperty("port")

/** Serial port used to read temp sensor */
@JsonProperty("serialPort")

/** stub the temperature sensor */
@JsonProperty("stubTemparature")

/** stub the webrelay */
@JsonProperty("stubRelay")

/** lowest acceptable temperature */
@JsonProperty("minTemp")

/** highest acceptable temperature */
@JsonProperty("maxTemp")

/** safety margin, when temperature at maxTemp + maxMargin Fritzy will be turned on regardless of market position */
@JsonProperty("maxMargin")

/**  The power consumption of Fritzy in Watt (in lieu of a power meter) used for calculating the amount of energy to buy and to report consumption */
@JsonProperty("power")

/** The leakage rate of Fritzy in °C per second (when turned off) */
@JsonProperty("leakageRate")

/** The cooling speed of Fritzy in °C per second (when turned on) */
@JsonProperty("coolingSpeed")

/** offset in euro cent used at the start of the negation. First bid will be market - offset. */
@JsonProperty("marketPriceStartOffset")


## Sunny
/** EFI id of the device */
@JsonProperty("deviceId")

/** offset in euro cent used at the start of the negation. First bid will be marketprice + offset. */
@JsonProperty("marketPriceStartOffset")

/** use stub instead of inverter */
@JsonProperty("useSolarEdgeStub")

/** base URL to SolarEdge monitoring portal. Used to retrieve hourly values which are needed by pvCast */
@JsonProperty("solarEdgeMonitoringBaseURL")

/** API key for SolarEdge monitoring portal. */
@JsonProperty("solarEdgeMonitoringApikey")

/** base URL to pvCast. pvCast supplies the forecasts so Sunny 'knows' how much energy it has to offer */
@JsonProperty("pvCastBaseURL")

/** API key for pvCast. */
@JsonProperty("pvCastApiKey")

/** IP address of the SolarEdge inverter */
@JsonProperty("solarEdgeModbusIpAddress")

/** modbus port of the SolarEdge inverter */
@JsonProperty("solarEdgeModbusPort")

/** modbus device id of the SolarEdge inverter */
@JsonProperty("solarEdgeModbusDeviceId")


## Netty
/** EFI devide id */
@JsonProperty("deviceId")

/** Base URL for the ENTSO-E API: https://transparency.entsoe.eu/api */
@JsonProperty("baseURL")

/**  Security token (access token) as supplied by ENTSO-E.
NOTE: This is a person bound token, every user of this code should obtain their own access token! See https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html#_authentication_and_authorisation */
@JsonProperty("securityToken")

/** How much kWh can exxy sell in a trade period */
@JsonProperty("capacity")

/** Map with fixed prices in EUR per kWh for every hour of the day (local time). Hours > 23 are ignored. When useFixedPrices is true these fixed prices are used instead of the live day ahead prices. */
@JsonProperty("fixedPrices")

/** When true the prices from fixedPrices are used instead of the live day ahead prices. */
@JsonProperty("useFixedPrices")

/** For each size in the given list an order to buy and sell is created. */
@JsonProperty("orderSizes")

## Batty
/** EFI id of the device */
@JsonProperty("deviceId")

/** host address of XStorage battery */
@JsonProperty("host")

/** XStorage API username */
@JsonProperty("username")

/** XStorage API password */
@JsonProperty("password")

/** truststore for https connection to XStorage */
@JsonProperty("truststore")

/** truststore password */
@JsonProperty("truststorepass")

/** buy margin in cents */
@JsonProperty("buyMargin")

/** sell margin in cents */
@JsonProperty("sellMargin")

/** run application with stubbed battery */
@JsonProperty("useStub")

## Exxy
/** EFI devide id */
@JsonProperty("deviceId")

/** Base URL for the ENTSO-E API: https://transparency.entsoe.eu/api */
@JsonProperty("baseURL")

/**
 * Security token (access token) as supplied by ENTSO-E.
 * 
 * NOTE: This is a person bound token, every user of this code should obtain their own access token! See
 * https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html
 * #_authentication_and_authorisation
 */
@JsonProperty("securityToken")

/** How much kWh can exxy sell in a trade period, currently not implemented */
@JsonProperty("capacity")

/**
 * Map with fixed prices in EUR per kWh for every hour of the day (local time). Hours > 23 are ignored. When
 * {@link useFixedPrices} is true these fixed prices are used instead of the live day ahead prices.
 */
@JsonProperty("fixedPrices")

/** When true the prices from {@link fixedPrices} are used instead of the live day ahead prices. */
@JsonProperty("useFixedPrices")

/** For each size in the given list an order to buy and sell is created. */
@JsonProperty("orderSizes")